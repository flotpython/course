# -*- eval: (auto-fill-mode 0) -*-

# TITRE SEMAINE 3 : Références partagées et itérateurs 

###################################################################

## Vidéo 1 (Tables de hash)

C012AL-W3-S1.txt 

## Compléments Vidéo 1 
pas de complement ni exercice sur ce topic tres abstrait
## Quizz Vidéo 1
## Exercices Vidéo 1


###################################################################

## Vidéo 2 (Les dictionnaires)

C012AL-W3-S2.txt 

## Compléments Vidéo 2
OK C012AL-W3-S2-C1-dict-extras.ipynb - recapitulatif sur comment utiliser un dict + url vers la doc python
OK C012AL-W3-S2-C2-dict-key-immuable.ipynb - types immuables et clés globalement immuables
OK C012AL-W3-S2-C3-dict-as-struct.ipynb - une utilisation standard du dictionnaire pour faire un struct

## Quizz Vidéo 2
OK C012AL-W3-S2-E1-dicts.quiz - un quiz sur les dictionnaires

## Exercices Vidéo 2
OK C012AL-W3-S2-E2-marine-dict.ipynb - premier morceau de code un peu réel avec data/marine*.json -- assez simple - data et corrections OK
				               	       	       	      
ONGOING C012AL-W3-S2-E2-meteo-pending-to-postpone.ipynb - premier morceau de code un peu réel avec data/meteo.json 

###################################################################

## Vidéo 3 (Les ensembles)

C012AL-W3-S3.txt 

## Compléments Vidéo 3
OK C012AL-W3-S3-C1-set-extras.ipynb : recap. fonctions/methodes sur les ensembles

-------- 
XXX Inutile en fait puisque j'en parle dans la dernière vidéo du MOOC
BOF *test de performance sur le test d'appartenance entre list et set
pour expliquer qu'il faut toujours utiliser des sets
>>> timeit.timeit(setup= "x = range(2)", stmt = '"c" in x', number = 6000000)
1.042163089558322
>>> timeit.timeit(setup= "x = set(range(2))", stmt = '"c" in x', number = 6000000)
0.32964897792466274
>>> timeit.timeit(setup= "x = range(2)", stmt = '0 in x', number = 6000000)
0.3086782596151636
>>> timeit.timeit(setup= "x = set(range(2))", stmt = '0 in x', number = 6000000)
0.3819173343944584
--------


## Quizz Vidéo 3

## Exercices Vidéo 3
TODO : un quiz qui met l'accent sur le choix judicieux du type de base en fonction du probleme posé 
entre tuple, liste, dict, set (et pourquoi pas aussi frozenset si il faut hacher)

OK C012AL-W3-S3-E1-marine-set.ipynb - avec le même genre de données de marine traffic xxx version python à 
 
###################################################################

## Vidéo 4 (Les références partagées)

C012AL-W3-S4.txt 

## Compléments Vidéo 4
OK C012AL-W3-S4-C1-is-id.ipynb : function id(), operateur is,  les entiers implementes comme des singletons
OK C012AL-W3-S4-C2-references-circulaires.ipynb : une liste infinie; un exemple + utile de reference circulaire
OK C012AL-W3-S4-C3-copy.ipynb - make sure this comes after is-id 
OK C012AL-W3-S4-C4-del.ipynb *del a;  del L[i:j:k]; del d[clef]
OK C012AL-W3-S4-C5-assign-simultaneous.ipynb   a = b = []

BOF gc.ipynb peut-etre plus tard mais je vois ca comme un truc super scabreux (si on veut le faire correctement)
en plus sys.getrefcount c'est un detail d'implementation; je sais pas si pypy a ça par exemple
* sys.getrefcount()

## Quizz Vidéo 4
OK C012AL-W3-S4-E1-multiply.quiz liste=[[1]]*5 et demander une solution pour ne pas avoir de ref. partagées 

## Exercices Vidéo 4


DROPPED* exo pour voir jusqu'à quelle taille de chaîne de caractères (et quelle taille d'entier) 
                 Python arrête de faire des références partagées pour optimiser la mémoire. 
		 je laisse tomber car la fonction is_singleton e comporte de maniere bizarre
NICETOHAVE * essayer d'écrire un bout de code buggé et demander aux gens detrouver l'erreur en rajoutant une copie

###################################################################
## Vidéo 5 (Introduction aux modules)

C012AL-W3-S5.txt

## Compléments Vidéo 5
OK C012AL-W3-S5-C1-packages.ipynb
OK C012AL-W3-S5-C2-modules-and-path.ipynb: 
OK C012AL-W3-S5-C3-recap-import.ipynb : pourquoi il ne faut pas utiliser import *

## Exercices Vidéo 5
OK C012AL-W3-S5-E1-decode-zen.ipynb : décoder le zen de python à partir de this (de import this) 

## Quizz Vidéo 5  

TODO ? un exo (sans correction) qui invite les etudiants
  (*) basique: creer un module dans leur workingdir et a l'importer
  (*) intermediaire: creer un package "utils" dans le workingdir avec un module dedans

ça pourrait se faire avec un quiz en dessous pour voir si les gens y arrivent,

###################################################################

## Vidéo 6 (L'indentation comme syntaxe de base)

C012AL-W3-S6.txt

## Compléments Vidéo 6
OK C012AL-W3-S6-C1-presentation.ipynb

## Quizz Vidéo 6

## Exercices Vidéo 6
XXX je n'ai aucune idée pour un exercice intéressant ici, ou bien ?

###################################################################

## Vidéo 7 (Les tests if/elif/else et les opérateurs booléens)
# if avec resultat non booleen
# operateurs booleens - priorites..

C012AL-W3-S7.txt

## Compléments Vidéo 7

## Quizz Vidéo 7

## Exercices Vidéo 7

-opérateurs de tests booléens and, or, not (vu en cours, montrer
d'autres exemples)
-insister sur le fait qu'il vaut mieux mettre des parenthèses que 
de compter sur les priorités. 
-opération shortcircuit and et or. Montrer des exemples pour les 2.
-discuter de == : quand peut-on comparer des objets de types différents
(seulement les numériques, et les set et frozenset, str/unicode, mais
(1, 2) n'est pas égal à [1, 2])
-quel sens à des comparaisons (avec < ou >) de listes ou dicts. 
-parler de bool (qui permet de connaitre le résultat d'un test) 
(je rajoute __nonzero__ lorsque l'on parlera de surcharge, c'est trop
tôt maintenant)


###################################################################

## Vidéo 8 (Les boucles for et les itérateurs)

C012AL-W3-S8.txt
# for sur une sequence - for sur un objet qui a un iterateur -
# __iter__  / next / StopIteration

## Compléments Vidéo 8

OK C012AL-W3-S8-C1-break-continue.ipynb
TODO C012AL-W3-S8-C2-iterateur-memoire.ipynb: un iterateur sur les permutations
TODO C012AL-W3-S8-C3-keep-intact.ipynb: il ne faut pas pas modifier l'objet sur lequel on fait un for 

- expliquer l'intérêt au niveau occupation mémoire des itérateurs
des types built-in.
-présenter break
-présenter continue (en expliquant que, comme pour les goto, les sauts
dans le code nuisent à la compréhension, il faut donc l'éviter)
-présenter pass qui est utilisé pour rendre syntaxiquement correct un bloc
de code que l'on n'a pas encore écrit (voir pour les fonctions, for, if)
-voir le else du for
-présenter enumerate, zip, et les itérateurs des dictionnaires
-présenter xrange() et sont avantage par rapport à range() (pas 
d'occupation mémoire). Dans le même esprit expliquer l'avantage
des itérateurs sur des dict (iteritems/itervalues/iterkeys) par rapport
aux listes. 
-présenter la méthode built-in iter() en expliquant que comme
__iter__() est une méthode Python privée, on ne doit pas l'appeler
directement dans un programme, on doit utiliser la built-in iter()
à la place.



Ici, sinon on a une boucle infinie.

## Quizz Vidéo 8

## Exercices Vidéo 8

Il ne faut pas modifier l'objet sur lequel on itère dans boucle for.
Si on modifie l'objet, il faut itérer sur copie
>>> L = ['a', 'b' , 'c']
>>> for i in L[:]:
	if i == 'c':
		L.append(i)	


